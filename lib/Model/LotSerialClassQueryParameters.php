<?php
/**
 * LotSerialClassQueryParameters
 *
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Visma.net ERP API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.18.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Model;

use \ArrayAccess;
use \OpenAPI\Client\ObjectSerializer;

/**
 * LotSerialClassQueryParameters Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 * @implements \ArrayAccess<string, mixed>
 */
class LotSerialClassQueryParameters implements ModelInterface, ArrayAccess, \JsonSerializable
{
    public const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $openAPIModelName = 'LotSerialClassQueryParameters';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $openAPITypes = [
        'description' => 'string',
        'tracking_method' => 'string',
        'track_expiration_date' => 'bool',
        'required_for_drop_ship' => 'bool',
        'assignment_method' => 'string',
        'issue_method' => 'string',
        'auto_incremental_value_between_classes' => 'bool',
        'auto_incremental_value' => 'string',
        'auto_generate_next_number' => 'bool',
        'last_modified_date_time' => 'string',
        'last_modified_date_time_condition' => 'string',
        'page_number' => 'int',
        'page_size' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      * @phpstan-var array<string, string|null>
      * @psalm-var array<string, string|null>
      */
    protected static $openAPIFormats = [
        'description' => null,
        'tracking_method' => null,
        'track_expiration_date' => null,
        'required_for_drop_ship' => null,
        'assignment_method' => null,
        'issue_method' => null,
        'auto_incremental_value_between_classes' => null,
        'auto_incremental_value' => null,
        'auto_generate_next_number' => null,
        'last_modified_date_time' => null,
        'last_modified_date_time_condition' => null,
        'page_number' => 'int32',
        'page_size' => 'int32'
    ];

    /**
      * Array of nullable properties. Used for (de)serialization
      *
      * @var boolean[]
      */
    protected static array $openAPINullables = [
        'description' => false,
        'tracking_method' => false,
        'track_expiration_date' => false,
        'required_for_drop_ship' => false,
        'assignment_method' => false,
        'issue_method' => false,
        'auto_incremental_value_between_classes' => false,
        'auto_incremental_value' => false,
        'auto_generate_next_number' => false,
        'last_modified_date_time' => false,
        'last_modified_date_time_condition' => false,
        'page_number' => false,
        'page_size' => false
    ];

    /**
      * If a nullable field gets set to null, insert it here
      *
      * @var boolean[]
      */
    protected array $openAPINullablesSetToNull = [];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPITypes()
    {
        return self::$openAPITypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function openAPIFormats()
    {
        return self::$openAPIFormats;
    }

    /**
     * Array of nullable properties
     *
     * @return array
     */
    protected static function openAPINullables(): array
    {
        return self::$openAPINullables;
    }

    /**
     * Array of nullable field names deliberately set to null
     *
     * @return boolean[]
     */
    private function getOpenAPINullablesSetToNull(): array
    {
        return $this->openAPINullablesSetToNull;
    }

    /**
     * Setter - Array of nullable field names deliberately set to null
     *
     * @param boolean[] $openAPINullablesSetToNull
     */
    private function setOpenAPINullablesSetToNull(array $openAPINullablesSetToNull): void
    {
        $this->openAPINullablesSetToNull = $openAPINullablesSetToNull;
    }

    /**
     * Checks if a property is nullable
     *
     * @param string $property
     * @return bool
     */
    public static function isNullable(string $property): bool
    {
        return self::openAPINullables()[$property] ?? false;
    }

    /**
     * Checks if a nullable property is set to null.
     *
     * @param string $property
     * @return bool
     */
    public function isNullableSetToNull(string $property): bool
    {
        return in_array($property, $this->getOpenAPINullablesSetToNull(), true);
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'description' => 'description',
        'tracking_method' => 'trackingMethod',
        'track_expiration_date' => 'trackExpirationDate',
        'required_for_drop_ship' => 'requiredForDropShip',
        'assignment_method' => 'assignmentMethod',
        'issue_method' => 'issueMethod',
        'auto_incremental_value_between_classes' => 'autoIncrementalValueBetweenClasses',
        'auto_incremental_value' => 'autoIncrementalValue',
        'auto_generate_next_number' => 'autoGenerateNextNumber',
        'last_modified_date_time' => 'lastModifiedDateTime',
        'last_modified_date_time_condition' => 'lastModifiedDateTimeCondition',
        'page_number' => 'pageNumber',
        'page_size' => 'pageSize'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'description' => 'setDescription',
        'tracking_method' => 'setTrackingMethod',
        'track_expiration_date' => 'setTrackExpirationDate',
        'required_for_drop_ship' => 'setRequiredForDropShip',
        'assignment_method' => 'setAssignmentMethod',
        'issue_method' => 'setIssueMethod',
        'auto_incremental_value_between_classes' => 'setAutoIncrementalValueBetweenClasses',
        'auto_incremental_value' => 'setAutoIncrementalValue',
        'auto_generate_next_number' => 'setAutoGenerateNextNumber',
        'last_modified_date_time' => 'setLastModifiedDateTime',
        'last_modified_date_time_condition' => 'setLastModifiedDateTimeCondition',
        'page_number' => 'setPageNumber',
        'page_size' => 'setPageSize'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'description' => 'getDescription',
        'tracking_method' => 'getTrackingMethod',
        'track_expiration_date' => 'getTrackExpirationDate',
        'required_for_drop_ship' => 'getRequiredForDropShip',
        'assignment_method' => 'getAssignmentMethod',
        'issue_method' => 'getIssueMethod',
        'auto_incremental_value_between_classes' => 'getAutoIncrementalValueBetweenClasses',
        'auto_incremental_value' => 'getAutoIncrementalValue',
        'auto_generate_next_number' => 'getAutoGenerateNextNumber',
        'last_modified_date_time' => 'getLastModifiedDateTime',
        'last_modified_date_time_condition' => 'getLastModifiedDateTimeCondition',
        'page_number' => 'getPageNumber',
        'page_size' => 'getPageSize'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$openAPIModelName;
    }

    public const TRACKING_METHOD_NOT_NUMBERED = 'NotNumbered';
    public const TRACKING_METHOD_LOT_NUMBERED = 'LotNumbered';
    public const TRACKING_METHOD_SERIAL_NUMBERED = 'SerialNumbered';
    public const ASSIGNMENT_METHOD_WHEN_RECEIVED = 'WhenReceived';
    public const ASSIGNMENT_METHOD_WHEN_USED = 'WhenUsed';
    public const ISSUE_METHOD_FIFO = 'FIFO';
    public const ISSUE_METHOD_LIFO = 'LIFO';
    public const ISSUE_METHOD_SEQUENTIAL = 'Sequential';
    public const ISSUE_METHOD_EXPIRATION = 'Expiration';
    public const ISSUE_METHOD_USER_ENTERABLE = 'UserEnterable';

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTrackingMethodAllowableValues()
    {
        return [
            self::TRACKING_METHOD_NOT_NUMBERED,
            self::TRACKING_METHOD_LOT_NUMBERED,
            self::TRACKING_METHOD_SERIAL_NUMBERED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAssignmentMethodAllowableValues()
    {
        return [
            self::ASSIGNMENT_METHOD_WHEN_RECEIVED,
            self::ASSIGNMENT_METHOD_WHEN_USED,
        ];
    }

    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getIssueMethodAllowableValues()
    {
        return [
            self::ISSUE_METHOD_FIFO,
            self::ISSUE_METHOD_LIFO,
            self::ISSUE_METHOD_SEQUENTIAL,
            self::ISSUE_METHOD_EXPIRATION,
            self::ISSUE_METHOD_USER_ENTERABLE,
        ];
    }

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[]|null $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(?array $data = null)
    {
        $this->setIfExists('description', $data ?? [], null);
        $this->setIfExists('tracking_method', $data ?? [], null);
        $this->setIfExists('track_expiration_date', $data ?? [], null);
        $this->setIfExists('required_for_drop_ship', $data ?? [], null);
        $this->setIfExists('assignment_method', $data ?? [], null);
        $this->setIfExists('issue_method', $data ?? [], null);
        $this->setIfExists('auto_incremental_value_between_classes', $data ?? [], null);
        $this->setIfExists('auto_incremental_value', $data ?? [], null);
        $this->setIfExists('auto_generate_next_number', $data ?? [], null);
        $this->setIfExists('last_modified_date_time', $data ?? [], null);
        $this->setIfExists('last_modified_date_time_condition', $data ?? [], null);
        $this->setIfExists('page_number', $data ?? [], null);
        $this->setIfExists('page_size', $data ?? [], null);
    }

    /**
    * Sets $this->container[$variableName] to the given data or to the given default Value; if $variableName
    * is nullable and its value is set to null in the $fields array, then mark it as "set to null" in the
    * $this->openAPINullablesSetToNull array
    *
    * @param string $variableName
    * @param array  $fields
    * @param mixed  $defaultValue
    */
    private function setIfExists(string $variableName, array $fields, $defaultValue): void
    {
        if (self::isNullable($variableName) && array_key_exists($variableName, $fields) && is_null($fields[$variableName])) {
            $this->openAPINullablesSetToNull[] = $variableName;
        }

        $this->container[$variableName] = $fields[$variableName] ?? $defaultValue;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getTrackingMethodAllowableValues();
        if (!is_null($this->container['tracking_method']) && !in_array($this->container['tracking_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'tracking_method', must be one of '%s'",
                $this->container['tracking_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAssignmentMethodAllowableValues();
        if (!is_null($this->container['assignment_method']) && !in_array($this->container['assignment_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'assignment_method', must be one of '%s'",
                $this->container['assignment_method'],
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getIssueMethodAllowableValues();
        if (!is_null($this->container['issue_method']) && !in_array($this->container['issue_method'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value '%s' for 'issue_method', must be one of '%s'",
                $this->container['issue_method'],
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets description
     *
     * @return string|null
     */
    public function getDescription()
    {
        return $this->container['description'];
    }

    /**
     * Sets description
     *
     * @param string|null $description description
     *
     * @return self
     */
    public function setDescription($description)
    {
        if (is_null($description)) {
            throw new \InvalidArgumentException('non-nullable description cannot be null');
        }
        $this->container['description'] = $description;

        return $this;
    }

    /**
     * Gets tracking_method
     *
     * @return string|null
     */
    public function getTrackingMethod()
    {
        return $this->container['tracking_method'];
    }

    /**
     * Sets tracking_method
     *
     * @param string|null $tracking_method tracking_method
     *
     * @return self
     */
    public function setTrackingMethod($tracking_method)
    {
        if (is_null($tracking_method)) {
            throw new \InvalidArgumentException('non-nullable tracking_method cannot be null');
        }
        $allowedValues = $this->getTrackingMethodAllowableValues();
        if (!in_array($tracking_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'tracking_method', must be one of '%s'",
                    $tracking_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['tracking_method'] = $tracking_method;

        return $this;
    }

    /**
     * Gets track_expiration_date
     *
     * @return bool|null
     */
    public function getTrackExpirationDate()
    {
        return $this->container['track_expiration_date'];
    }

    /**
     * Sets track_expiration_date
     *
     * @param bool|null $track_expiration_date track_expiration_date
     *
     * @return self
     */
    public function setTrackExpirationDate($track_expiration_date)
    {
        if (is_null($track_expiration_date)) {
            throw new \InvalidArgumentException('non-nullable track_expiration_date cannot be null');
        }
        $this->container['track_expiration_date'] = $track_expiration_date;

        return $this;
    }

    /**
     * Gets required_for_drop_ship
     *
     * @return bool|null
     */
    public function getRequiredForDropShip()
    {
        return $this->container['required_for_drop_ship'];
    }

    /**
     * Sets required_for_drop_ship
     *
     * @param bool|null $required_for_drop_ship required_for_drop_ship
     *
     * @return self
     */
    public function setRequiredForDropShip($required_for_drop_ship)
    {
        if (is_null($required_for_drop_ship)) {
            throw new \InvalidArgumentException('non-nullable required_for_drop_ship cannot be null');
        }
        $this->container['required_for_drop_ship'] = $required_for_drop_ship;

        return $this;
    }

    /**
     * Gets assignment_method
     *
     * @return string|null
     */
    public function getAssignmentMethod()
    {
        return $this->container['assignment_method'];
    }

    /**
     * Sets assignment_method
     *
     * @param string|null $assignment_method assignment_method
     *
     * @return self
     */
    public function setAssignmentMethod($assignment_method)
    {
        if (is_null($assignment_method)) {
            throw new \InvalidArgumentException('non-nullable assignment_method cannot be null');
        }
        $allowedValues = $this->getAssignmentMethodAllowableValues();
        if (!in_array($assignment_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'assignment_method', must be one of '%s'",
                    $assignment_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['assignment_method'] = $assignment_method;

        return $this;
    }

    /**
     * Gets issue_method
     *
     * @return string|null
     */
    public function getIssueMethod()
    {
        return $this->container['issue_method'];
    }

    /**
     * Sets issue_method
     *
     * @param string|null $issue_method issue_method
     *
     * @return self
     */
    public function setIssueMethod($issue_method)
    {
        if (is_null($issue_method)) {
            throw new \InvalidArgumentException('non-nullable issue_method cannot be null');
        }
        $allowedValues = $this->getIssueMethodAllowableValues();
        if (!in_array($issue_method, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value '%s' for 'issue_method', must be one of '%s'",
                    $issue_method,
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['issue_method'] = $issue_method;

        return $this;
    }

    /**
     * Gets auto_incremental_value_between_classes
     *
     * @return bool|null
     */
    public function getAutoIncrementalValueBetweenClasses()
    {
        return $this->container['auto_incremental_value_between_classes'];
    }

    /**
     * Sets auto_incremental_value_between_classes
     *
     * @param bool|null $auto_incremental_value_between_classes auto_incremental_value_between_classes
     *
     * @return self
     */
    public function setAutoIncrementalValueBetweenClasses($auto_incremental_value_between_classes)
    {
        if (is_null($auto_incremental_value_between_classes)) {
            throw new \InvalidArgumentException('non-nullable auto_incremental_value_between_classes cannot be null');
        }
        $this->container['auto_incremental_value_between_classes'] = $auto_incremental_value_between_classes;

        return $this;
    }

    /**
     * Gets auto_incremental_value
     *
     * @return string|null
     */
    public function getAutoIncrementalValue()
    {
        return $this->container['auto_incremental_value'];
    }

    /**
     * Sets auto_incremental_value
     *
     * @param string|null $auto_incremental_value auto_incremental_value
     *
     * @return self
     */
    public function setAutoIncrementalValue($auto_incremental_value)
    {
        if (is_null($auto_incremental_value)) {
            throw new \InvalidArgumentException('non-nullable auto_incremental_value cannot be null');
        }
        $this->container['auto_incremental_value'] = $auto_incremental_value;

        return $this;
    }

    /**
     * Gets auto_generate_next_number
     *
     * @return bool|null
     */
    public function getAutoGenerateNextNumber()
    {
        return $this->container['auto_generate_next_number'];
    }

    /**
     * Sets auto_generate_next_number
     *
     * @param bool|null $auto_generate_next_number auto_generate_next_number
     *
     * @return self
     */
    public function setAutoGenerateNextNumber($auto_generate_next_number)
    {
        if (is_null($auto_generate_next_number)) {
            throw new \InvalidArgumentException('non-nullable auto_generate_next_number cannot be null');
        }
        $this->container['auto_generate_next_number'] = $auto_generate_next_number;

        return $this;
    }

    /**
     * Gets last_modified_date_time
     *
     * @return string|null
     */
    public function getLastModifiedDateTime()
    {
        return $this->container['last_modified_date_time'];
    }

    /**
     * Sets last_modified_date_time
     *
     * @param string|null $last_modified_date_time last_modified_date_time
     *
     * @return self
     */
    public function setLastModifiedDateTime($last_modified_date_time)
    {
        if (is_null($last_modified_date_time)) {
            throw new \InvalidArgumentException('non-nullable last_modified_date_time cannot be null');
        }
        $this->container['last_modified_date_time'] = $last_modified_date_time;

        return $this;
    }

    /**
     * Gets last_modified_date_time_condition
     *
     * @return string|null
     */
    public function getLastModifiedDateTimeCondition()
    {
        return $this->container['last_modified_date_time_condition'];
    }

    /**
     * Sets last_modified_date_time_condition
     *
     * @param string|null $last_modified_date_time_condition last_modified_date_time_condition
     *
     * @return self
     */
    public function setLastModifiedDateTimeCondition($last_modified_date_time_condition)
    {
        if (is_null($last_modified_date_time_condition)) {
            throw new \InvalidArgumentException('non-nullable last_modified_date_time_condition cannot be null');
        }
        $this->container['last_modified_date_time_condition'] = $last_modified_date_time_condition;

        return $this;
    }

    /**
     * Gets page_number
     *
     * @return int|null
     */
    public function getPageNumber()
    {
        return $this->container['page_number'];
    }

    /**
     * Sets page_number
     *
     * @param int|null $page_number Pagination parameter. Page number.
     *
     * @return self
     */
    public function setPageNumber($page_number)
    {
        if (is_null($page_number)) {
            throw new \InvalidArgumentException('non-nullable page_number cannot be null');
        }
        $this->container['page_number'] = $page_number;

        return $this;
    }

    /**
     * Gets page_size
     *
     * @return int|null
     */
    public function getPageSize()
    {
        return $this->container['page_size'];
    }

    /**
     * Sets page_size
     *
     * @param int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size.
     *
     * @return self
     */
    public function setPageSize($page_size)
    {
        if (is_null($page_size)) {
            throw new \InvalidArgumentException('non-nullable page_size cannot be null');
        }
        $this->container['page_size'] = $page_size;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer|string $offset Offset
     *
     * @return boolean
     */
    public function offsetExists(mixed $offset): bool
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return mixed|null
     */
    #[\ReturnTypeWillChange]
    public function offsetGet(mixed $offset)
    {
        return $this->container[$offset] ?? null;
    }

    /**
     * Sets value based on offset.
     *
     * @param int|null $offset Offset
     * @param mixed    $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value): void
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer|string $offset Offset
     *
     * @return void
     */
    public function offsetUnset(mixed $offset): void
    {
        unset($this->container[$offset]);
    }

    /**
     * Serializes the object to a value that can be serialized natively by json_encode().
     * @link https://www.php.net/manual/en/jsonserializable.jsonserialize.php
     *
     * @return mixed Returns data which can be serialized by json_encode(), which is a value
     * of any type other than a resource.
     */
    #[\ReturnTypeWillChange]
    public function jsonSerialize()
    {
       return ObjectSerializer::sanitizeForSerialization($this);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        return json_encode(
            ObjectSerializer::sanitizeForSerialization($this),
            JSON_PRETTY_PRINT
        );
    }

    /**
     * Gets a header-safe presentation of the object
     *
     * @return string
     */
    public function toHeaderValue()
    {
        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


