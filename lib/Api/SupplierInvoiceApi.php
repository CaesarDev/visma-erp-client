<?php
/**
 * SupplierInvoiceApi
 * PHP version 8.1
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * Visma.net ERP API
 *
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.18.0-SNAPSHOT
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace OpenAPI\Client\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use OpenAPI\Client\ApiException;
use OpenAPI\Client\Configuration;
use OpenAPI\Client\FormDataProcessor;
use OpenAPI\Client\HeaderSelector;
use OpenAPI\Client\ObjectSerializer;

/**
 * SupplierInvoiceApi Class Doc Comment
 *
 * @category Class
 * @package  OpenAPI\Client
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class SupplierInvoiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'supplierInvoiceCorrectInvoiceByinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceCreateHeaderAttachmentByinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber' => [
            'application/json',
        ],
        'supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber' => [
            'application/json',
        ],
        'supplierInvoiceDeleteBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceDeleteByinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceGetAllInvoices' => [
            'application/json',
        ],
        'supplierInvoiceGetByApprovalDocumentId' => [
            'application/json',
        ],
        'supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceGetByinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoicePost' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'supplierInvoicePutByTypeBydocumentTypeinvoiceNumber' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'supplierInvoicePutByinvoiceNumber' => [
            'application/json',
            'text/json',
            'application/xml',
            'text/xml',
            'application/x-www-form-urlencoded',
        ],
        'supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceReleaseInvoiceByinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
        'supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber' => [
            'application/json',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation supplierInvoiceCorrectInvoiceByinvoiceNumber
     *
     * Correct invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be corrected (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceCorrectInvoiceByinvoiceNumber($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceCorrectInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceCorrectInvoiceByinvoiceNumberWithHttpInfo
     *
     * Correct invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be corrected (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCorrectInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceCorrectInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCorrectInvoiceByinvoiceNumberAsync
     *
     * Correct invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be corrected (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCorrectInvoiceByinvoiceNumberAsync($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'][0])
    {
        return $this->supplierInvoiceCorrectInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCorrectInvoiceByinvoiceNumberAsyncWithHttpInfo
     *
     * Correct invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be corrected (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCorrectInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceCorrectInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCorrectInvoiceByinvoiceNumber'
     *
     * @param  string $invoice_number Reference number of the document to be corrected (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceCorrectInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCorrectInvoiceByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCorrectInvoiceByinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}/action/correct';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateHeaderAttachmentByTypeBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/documentType/{documentType}/{invoiceNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumber
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumber($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsync
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsync($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'][0])
    {
        return $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a supplier invoice. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'][0])
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceCreateHeaderAttachmentByinvoiceNumberRequest($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateHeaderAttachmentByinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber($document_type, $invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'][0])
    {
        list($response) = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo($document_type, $invoice_number, $line_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberWithHttpInfo($document_type, $invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'][0])
    {
        $request = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsync($document_type, $invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'][0])
    {
        return $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo($document_type, $invoice_number, $line_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberAsyncWithHttpInfo($document_type, $invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'][0])
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
     *
     * @param  string $document_type  (required)
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Identifies the supplier invoice line (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumberRequest($document_type, $invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }

        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling supplierInvoiceCreateLineAttachmentByTypeBydocumentTypeinvoiceNumberlineNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/documentType/{documentType}/{invoiceNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber($invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'][0])
    {
        list($response) = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberWithHttpInfo($invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'][0])
    {
        $request = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsync($invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'][0])
    {
        return $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo
     *
     * Creates an attachment and associates it with a certain supplier invoice line. If the file already exists, a new revision is created.
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberAsyncWithHttpInfo($invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'][0])
    {
        $returnType = 'object';
        $request = $this->supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
     *
     * @param  string $invoice_number Identifies the supplier invoice (required)
     * @param  int $line_number Specifies line number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumberRequest($invoice_number, $line_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }

        // verify the required parameter 'line_number' is set
        if ($line_number === null || (is_array($line_number) && count($line_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $line_number when calling supplierInvoiceCreateLineAttachmentByinvoiceNumberlineNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}/{lineNumber}/attachment';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }
        // path params
        if ($line_number !== null) {
            $resourcePath = str_replace(
                '{' . 'lineNumber' . '}',
                ObjectSerializer::toPathValue($line_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumber
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsync
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the docType of Supplier Invoice to delete (required)
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceDeleteBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceDeleteBydocumentTypeinvoiceNumber'
            );
        }



        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumber
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceDeleteByinvoiceNumber($invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceDeleteByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberAsync
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteByinvoiceNumberAsync($invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'][0])
    {
        return $this->supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo
     *
     * Deletes a specific Supplier Invoice
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceDeleteByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceDeleteByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Supplier Invoice to delete (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceDeleteByinvoiceNumberRequest($invoice_number, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceDeleteByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceDeleteByinvoiceNumber'
            );
        }



        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'DELETE',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetAllInvoices
     *
     * Get a range of Invoices - ScreenId&#x3D;AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string|null $supplier Filter by Supplier (optional)
     * @param  bool|null $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  bool|null $expand_landed_costs Expland landed cost lines (optional)
     * @param  string|null $document_type By type of document. (optional)
     * @param  int|null $released Parameter for showing if invoice has been released or not. (optional)
     * @param  string|null $project Filter by the project with which the document is associated. (optional)
     * @param  bool|null $expand_approval Set to true to include approval information. (optional)
     * @param  bool|null $expand_note Set to true to include description. (optional)
     * @param  int|null $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int|null $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string|null $status The status of the document (optional)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  string|null $branch Filter by Branch (optional)
     * @param  string|null $financial_period Filter by Financial Period, format YYYYPP (optional)
     * @param  \DateTime|null $due_date This value indicates the date the document is due for payment. Use it to retrieve all records that have the Due date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __DueDate__ and __DueDateConditionCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $due_date_condition This value represents the condition to be applied to the Due Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DueDate__ and __DueDateCondition__ are __mutually inclusive__. (optional)
     * @param  \DateTime|null $doc_date This value indicates the document date. Use it to retrieve all records that have the Document Date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __Docate__ and __DocDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $doc_date_condition This value represents the condition to be applied to the Document Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DocumentDate__ and __DocumentDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $item Filter by Item used into the document lines (optional)
     * @param  float|null $balance This value represents balance of the payment remaining to be applied and released. Only released applications will count towards the balance.    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $balance_condition This value represents the condition to be applied to the Balance when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string|null $last_modified_date_time This value, generated by the system, indicates the last time the record was modified. Use it to retrieve all records that have been modified since that time, up to the present.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss.FFF&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss.FFF&#x60;&#x60;&#x60;    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $last_modified_date_time_condition This value represents the condition to be applied when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $created_date_time Creation date and time. (optional)
     * @param  string|null $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int|null $page_number Pagination parameter. Page number. (optional)
     * @param  int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetAllInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SupplierInvoiceDto[]|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceGetAllInvoices($supplier = null, $expand_attachment = null, $expand_landed_costs = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $status = null, $expand_line_prebook_accounts = null, $branch = null, $financial_period = null, $due_date = null, $due_date_condition = null, $doc_date = null, $doc_date_condition = null, $item = null, $balance = null, $balance_condition = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetAllInvoices'][0])
    {
        list($response) = $this->supplierInvoiceGetAllInvoicesWithHttpInfo($supplier, $expand_attachment, $expand_landed_costs, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $status, $expand_line_prebook_accounts, $branch, $financial_period, $due_date, $due_date_condition, $doc_date, $doc_date_condition, $item, $balance, $balance_condition, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesWithHttpInfo
     *
     * Get a range of Invoices - ScreenId&#x3D;AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string|null $supplier Filter by Supplier (optional)
     * @param  bool|null $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  bool|null $expand_landed_costs Expland landed cost lines (optional)
     * @param  string|null $document_type By type of document. (optional)
     * @param  int|null $released Parameter for showing if invoice has been released or not. (optional)
     * @param  string|null $project Filter by the project with which the document is associated. (optional)
     * @param  bool|null $expand_approval Set to true to include approval information. (optional)
     * @param  bool|null $expand_note Set to true to include description. (optional)
     * @param  int|null $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int|null $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string|null $status The status of the document (optional)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  string|null $branch Filter by Branch (optional)
     * @param  string|null $financial_period Filter by Financial Period, format YYYYPP (optional)
     * @param  \DateTime|null $due_date This value indicates the date the document is due for payment. Use it to retrieve all records that have the Due date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __DueDate__ and __DueDateConditionCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $due_date_condition This value represents the condition to be applied to the Due Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DueDate__ and __DueDateCondition__ are __mutually inclusive__. (optional)
     * @param  \DateTime|null $doc_date This value indicates the document date. Use it to retrieve all records that have the Document Date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __Docate__ and __DocDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $doc_date_condition This value represents the condition to be applied to the Document Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DocumentDate__ and __DocumentDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $item Filter by Item used into the document lines (optional)
     * @param  float|null $balance This value represents balance of the payment remaining to be applied and released. Only released applications will count towards the balance.    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $balance_condition This value represents the condition to be applied to the Balance when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string|null $last_modified_date_time This value, generated by the system, indicates the last time the record was modified. Use it to retrieve all records that have been modified since that time, up to the present.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss.FFF&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss.FFF&#x60;&#x60;&#x60;    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $last_modified_date_time_condition This value represents the condition to be applied when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $created_date_time Creation date and time. (optional)
     * @param  string|null $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int|null $page_number Pagination parameter. Page number. (optional)
     * @param  int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetAllInvoices'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SupplierInvoiceDto[]|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetAllInvoicesWithHttpInfo($supplier = null, $expand_attachment = null, $expand_landed_costs = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $status = null, $expand_line_prebook_accounts = null, $branch = null, $financial_period = null, $due_date = null, $due_date_condition = null, $doc_date = null, $doc_date_condition = null, $item = null, $balance = null, $balance_condition = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetAllInvoices'][0])
    {
        $request = $this->supplierInvoiceGetAllInvoicesRequest($supplier, $expand_attachment, $expand_landed_costs, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $status, $expand_line_prebook_accounts, $branch, $financial_period, $due_date, $due_date_condition, $doc_date, $doc_date_condition, $item, $balance, $balance_condition, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SupplierInvoiceDto[]',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SupplierInvoiceDto[]',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SupplierInvoiceDto[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesAsync
     *
     * Get a range of Invoices - ScreenId&#x3D;AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string|null $supplier Filter by Supplier (optional)
     * @param  bool|null $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  bool|null $expand_landed_costs Expland landed cost lines (optional)
     * @param  string|null $document_type By type of document. (optional)
     * @param  int|null $released Parameter for showing if invoice has been released or not. (optional)
     * @param  string|null $project Filter by the project with which the document is associated. (optional)
     * @param  bool|null $expand_approval Set to true to include approval information. (optional)
     * @param  bool|null $expand_note Set to true to include description. (optional)
     * @param  int|null $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int|null $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string|null $status The status of the document (optional)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  string|null $branch Filter by Branch (optional)
     * @param  string|null $financial_period Filter by Financial Period, format YYYYPP (optional)
     * @param  \DateTime|null $due_date This value indicates the date the document is due for payment. Use it to retrieve all records that have the Due date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __DueDate__ and __DueDateConditionCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $due_date_condition This value represents the condition to be applied to the Due Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DueDate__ and __DueDateCondition__ are __mutually inclusive__. (optional)
     * @param  \DateTime|null $doc_date This value indicates the document date. Use it to retrieve all records that have the Document Date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __Docate__ and __DocDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $doc_date_condition This value represents the condition to be applied to the Document Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DocumentDate__ and __DocumentDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $item Filter by Item used into the document lines (optional)
     * @param  float|null $balance This value represents balance of the payment remaining to be applied and released. Only released applications will count towards the balance.    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $balance_condition This value represents the condition to be applied to the Balance when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string|null $last_modified_date_time This value, generated by the system, indicates the last time the record was modified. Use it to retrieve all records that have been modified since that time, up to the present.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss.FFF&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss.FFF&#x60;&#x60;&#x60;    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $last_modified_date_time_condition This value represents the condition to be applied when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $created_date_time Creation date and time. (optional)
     * @param  string|null $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int|null $page_number Pagination parameter. Page number. (optional)
     * @param  int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetAllInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetAllInvoicesAsync($supplier = null, $expand_attachment = null, $expand_landed_costs = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $status = null, $expand_line_prebook_accounts = null, $branch = null, $financial_period = null, $due_date = null, $due_date_condition = null, $doc_date = null, $doc_date_condition = null, $item = null, $balance = null, $balance_condition = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetAllInvoices'][0])
    {
        return $this->supplierInvoiceGetAllInvoicesAsyncWithHttpInfo($supplier, $expand_attachment, $expand_landed_costs, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $status, $expand_line_prebook_accounts, $branch, $financial_period, $due_date, $due_date_condition, $doc_date, $doc_date_condition, $item, $balance, $balance_condition, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetAllInvoicesAsyncWithHttpInfo
     *
     * Get a range of Invoices - ScreenId&#x3D;AP301000.   Request page size must be lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size
     *
     * @param  string|null $supplier Filter by Supplier (optional)
     * @param  bool|null $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  bool|null $expand_landed_costs Expland landed cost lines (optional)
     * @param  string|null $document_type By type of document. (optional)
     * @param  int|null $released Parameter for showing if invoice has been released or not. (optional)
     * @param  string|null $project Filter by the project with which the document is associated. (optional)
     * @param  bool|null $expand_approval Set to true to include approval information. (optional)
     * @param  bool|null $expand_note Set to true to include description. (optional)
     * @param  int|null $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int|null $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string|null $status The status of the document (optional)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  string|null $branch Filter by Branch (optional)
     * @param  string|null $financial_period Filter by Financial Period, format YYYYPP (optional)
     * @param  \DateTime|null $due_date This value indicates the date the document is due for payment. Use it to retrieve all records that have the Due date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __DueDate__ and __DueDateConditionCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $due_date_condition This value represents the condition to be applied to the Due Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DueDate__ and __DueDateCondition__ are __mutually inclusive__. (optional)
     * @param  \DateTime|null $doc_date This value indicates the document date. Use it to retrieve all records that have the Document Date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __Docate__ and __DocDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $doc_date_condition This value represents the condition to be applied to the Document Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DocumentDate__ and __DocumentDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $item Filter by Item used into the document lines (optional)
     * @param  float|null $balance This value represents balance of the payment remaining to be applied and released. Only released applications will count towards the balance.    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $balance_condition This value represents the condition to be applied to the Balance when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string|null $last_modified_date_time This value, generated by the system, indicates the last time the record was modified. Use it to retrieve all records that have been modified since that time, up to the present.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss.FFF&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss.FFF&#x60;&#x60;&#x60;    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $last_modified_date_time_condition This value represents the condition to be applied when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $created_date_time Creation date and time. (optional)
     * @param  string|null $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int|null $page_number Pagination parameter. Page number. (optional)
     * @param  int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetAllInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetAllInvoicesAsyncWithHttpInfo($supplier = null, $expand_attachment = null, $expand_landed_costs = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $status = null, $expand_line_prebook_accounts = null, $branch = null, $financial_period = null, $due_date = null, $due_date_condition = null, $doc_date = null, $doc_date_condition = null, $item = null, $balance = null, $balance_condition = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetAllInvoices'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SupplierInvoiceDto[]';
        $request = $this->supplierInvoiceGetAllInvoicesRequest($supplier, $expand_attachment, $expand_landed_costs, $document_type, $released, $project, $expand_approval, $expand_note, $number_to_read, $skip_records, $status, $expand_line_prebook_accounts, $branch, $financial_period, $due_date, $due_date_condition, $doc_date, $doc_date_condition, $item, $balance, $balance_condition, $greater_than_value, $last_modified_date_time, $last_modified_date_time_condition, $created_date_time, $created_date_time_condition, $page_number, $page_size, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetAllInvoices'
     *
     * @param  string|null $supplier Filter by Supplier (optional)
     * @param  bool|null $expand_attachment Set to true if you want to see all attachments regarding this document. (optional)
     * @param  bool|null $expand_landed_costs Expland landed cost lines (optional)
     * @param  string|null $document_type By type of document. (optional)
     * @param  int|null $released Parameter for showing if invoice has been released or not. (optional)
     * @param  string|null $project Filter by the project with which the document is associated. (optional)
     * @param  bool|null $expand_approval Set to true to include approval information. (optional)
     * @param  bool|null $expand_note Set to true to include description. (optional)
     * @param  int|null $number_to_read This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  int|null $skip_records This field has been deprecated and will be removed in future versions. Use pagenumber and pagesize for pagination purposes. Pagenumber and pagesize does not work with NumberToRead and SkipRecords. (optional)
     * @param  string|null $status The status of the document (optional)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  string|null $branch Filter by Branch (optional)
     * @param  string|null $financial_period Filter by Financial Period, format YYYYPP (optional)
     * @param  \DateTime|null $due_date This value indicates the date the document is due for payment. Use it to retrieve all records that have the Due date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __DueDate__ and __DueDateConditionCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $due_date_condition This value represents the condition to be applied to the Due Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DueDate__ and __DueDateCondition__ are __mutually inclusive__. (optional)
     * @param  \DateTime|null $doc_date This value indicates the document date. Use it to retrieve all records that have the Document Date since that time, up to the future.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;    _Note:_ __Docate__ and __DocDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $doc_date_condition This value represents the condition to be applied to the Document Date when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __DocumentDate__ and __DocumentDateCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $item Filter by Item used into the document lines (optional)
     * @param  float|null $balance This value represents balance of the payment remaining to be applied and released. Only released applications will count towards the balance.    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $balance_condition This value represents the condition to be applied to the Balance when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __Balance__ and __BalanceCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $greater_than_value Greater than value. The item which is the object for this, varies from API to API. (optional)
     * @param  string|null $last_modified_date_time This value, generated by the system, indicates the last time the record was modified. Use it to retrieve all records that have been modified since that time, up to the present.    Accepted format:  * &#x60;&#x60;&#x60;yyyy-MM-dd&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-dd HH:mm:ss.FFF&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss&#x60;&#x60;&#x60;  * &#x60;&#x60;&#x60;yyyy-MM-ddTHH:mm:ss.FFF&#x60;&#x60;&#x60;    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $last_modified_date_time_condition This value represents the condition to be applied when retrieving records.    Accepted values (without the single quotes):  * &#39;&amp;gt;&#39; for greater than  * &#39;&amp;lt;&#39; for less than  * &#39;&amp;gt;&#x3D;&#39; for greater than or equal  * &#39;&amp;lt;&#x3D;&#39; for less than or equal    _Note:_ __LastModifiedDateTime__ and __LastModifiedDateTimeCondition__ are __mutually inclusive__. (optional)
     * @param  string|null $created_date_time Creation date and time. (optional)
     * @param  string|null $created_date_time_condition System-retrieved information for state/condition (optional)
     * @param  int|null $page_number Pagination parameter. Page number. (optional)
     * @param  int|null $page_size Pagination parameter. Number of items to be collected.  Please use a page size lower or equal to the allowed max page size which is returned as part of the metadata information.  If requested page size is greater than allowed max page size, request will be limited to max page size. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetAllInvoices'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceGetAllInvoicesRequest($supplier = null, $expand_attachment = null, $expand_landed_costs = null, $document_type = null, $released = null, $project = null, $expand_approval = null, $expand_note = null, $number_to_read = null, $skip_records = null, $status = null, $expand_line_prebook_accounts = null, $branch = null, $financial_period = null, $due_date = null, $due_date_condition = null, $doc_date = null, $doc_date_condition = null, $item = null, $balance = null, $balance_condition = null, $greater_than_value = null, $last_modified_date_time = null, $last_modified_date_time_condition = null, $created_date_time = null, $created_date_time_condition = null, $page_number = null, $page_size = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetAllInvoices'][0])
    {































        $resourcePath = '/v1/supplierInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $supplier,
            'supplier', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_attachment,
            'expandAttachment', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_landed_costs,
            'expandLandedCosts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $document_type,
            'documentType', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $released,
            'released', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $project,
            'project', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_approval,
            'expandApproval', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_note,
            'expandNote', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $number_to_read,
            'numberToRead', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $skip_records,
            'skipRecords', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $status,
            'status', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_line_prebook_accounts,
            'expandLinePrebookAccounts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $branch,
            'branch', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $financial_period,
            'financialPeriod', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $due_date,
            'dueDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $due_date_condition,
            'dueDateCondition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doc_date,
            'docDate', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $doc_date_condition,
            'docDateCondition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $item,
            'item', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance,
            'balance', // param base name
            'number', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $balance_condition,
            'balanceCondition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $greater_than_value,
            'greaterThanValue', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_modified_date_time,
            'lastModifiedDateTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $last_modified_date_time_condition,
            'lastModifiedDateTimeCondition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_date_time,
            'createdDateTime', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $created_date_time_condition,
            'createdDateTimeCondition', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_number,
            'pageNumber', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page_size,
            'pageSize', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentId
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByApprovalDocumentId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceGetByApprovalDocumentId($system_id, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByApprovalDocumentId'][0])
    {
        list($response) = $this->supplierInvoiceGetByApprovalDocumentIdWithHttpInfo($system_id, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdWithHttpInfo
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByApprovalDocumentId'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByApprovalDocumentIdWithHttpInfo($system_id, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByApprovalDocumentId'][0])
    {
        $request = $this->supplierInvoiceGetByApprovalDocumentIdRequest($system_id, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SupplierInvoiceDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdAsync
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByApprovalDocumentId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByApprovalDocumentIdAsync($system_id, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByApprovalDocumentId'][0])
    {
        return $this->supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo($system_id, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo
     *
     * Get an invoice based on the systemId. SystemID is used for approving supplier invoices
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByApprovalDocumentId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByApprovalDocumentIdAsyncWithHttpInfo($system_id, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByApprovalDocumentId'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByApprovalDocumentIdRequest($system_id, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByApprovalDocumentId'
     *
     * @param  string $system_id SystemID referes to the approval document id created when the document is sent to approval (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByApprovalDocumentId'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceGetByApprovalDocumentIdRequest($system_id, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByApprovalDocumentId'][0])
    {

        // verify the required parameter 'system_id' is set
        if ($system_id === null || (is_array($system_id) && count($system_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $system_id when calling supplierInvoiceGetByApprovalDocumentId'
            );
        }



        $resourcePath = '/v1/supplierInvoice/approval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $system_id,
            'systemId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);

        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber
     *
     * Get a specific Invoice, DebitAdj, CreditAdj or Prepayment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Get a specific Invoice, DebitAdj, CreditAdj or Prepayment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SupplierInvoiceDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Get a specific Invoice, DebitAdj, CreditAdj or Prepayment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Get a specific Invoice, DebitAdj, CreditAdj or Prepayment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceGetByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceGetByTypeBydocumentTypeinvoiceNumber'
            );
        }





        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_line_prebook_accounts,
            'expandLinePrebookAccounts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_landed_costs,
            'expandLandedCosts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumber
     *
     * GET a specific invoice. Only standard invoices are supported. Credit adjustments, credit notes or Prepayments are excluded.
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceGetByinvoiceNumber($invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberWithHttpInfo
     *
     * GET a specific invoice. Only standard invoices are supported. Credit adjustments, credit notes or Prepayments are excluded.
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\SupplierInvoiceDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceGetByinvoiceNumberWithHttpInfo($invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceGetByinvoiceNumberRequest($invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\SupplierInvoiceDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\SupplierInvoiceDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberAsync
     *
     * GET a specific invoice. Only standard invoices are supported. Credit adjustments, credit notes or Prepayments are excluded.
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByinvoiceNumberAsync($invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByinvoiceNumber'][0])
    {
        return $this->supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo
     *
     * GET a specific invoice. Only standard invoices are supported. Credit adjustments, credit notes or Prepayments are excluded.
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceGetByinvoiceNumberAsyncWithHttpInfo($invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\SupplierInvoiceDto';
        $request = $this->supplierInvoiceGetByinvoiceNumberRequest($invoice_number, $expand_line_prebook_accounts, $expand_landed_costs, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceGetByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  bool|null $expand_line_prebook_accounts Expland line-level pre-booking account and sub-account information. (optional)
     * @param  bool|null $expand_landed_costs Expland landed costs information. (optional)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceGetByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceGetByinvoiceNumberRequest($invoice_number, $expand_line_prebook_accounts = null, $expand_landed_costs = null, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoiceGetByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceGetByinvoiceNumber'
            );
        }





        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_line_prebook_accounts,
            'expandLinePrebookAccounts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $expand_landed_costs,
            'expandLandedCosts', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);

        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePost
     *
     * Create an SupplierInvoice
     *
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the SupplierInvoice to create (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoicePost($supplier_invoice_update_dto, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoicePost'][0])
    {
        list($response) = $this->supplierInvoicePostWithHttpInfo($supplier_invoice_update_dto, $erp_api_background, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoicePostWithHttpInfo
     *
     * Create an SupplierInvoice
     *
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the SupplierInvoice to create (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePost'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePostWithHttpInfo($supplier_invoice_update_dto, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoicePost'][0])
    {
        $request = $this->supplierInvoicePostRequest($supplier_invoice_update_dto, $erp_api_background, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 201:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                'object',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 201:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePostAsync
     *
     * Create an SupplierInvoice
     *
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the SupplierInvoice to create (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePostAsync($supplier_invoice_update_dto, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoicePost'][0])
    {
        return $this->supplierInvoicePostAsyncWithHttpInfo($supplier_invoice_update_dto, $erp_api_background, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePostAsyncWithHttpInfo
     *
     * Create an SupplierInvoice
     *
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the SupplierInvoice to create (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePostAsyncWithHttpInfo($supplier_invoice_update_dto, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoicePost'][0])
    {
        $returnType = 'object';
        $request = $this->supplierInvoicePostRequest($supplier_invoice_update_dto, $erp_api_background, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePost'
     *
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the SupplierInvoice to create (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoicePostRequest($supplier_invoice_update_dto, $erp_api_background = null, string $contentType = self::contentTypes['supplierInvoicePost'][0])
    {

        // verify the required parameter 'supplier_invoice_update_dto' is set
        if ($supplier_invoice_update_dto === null || (is_array($supplier_invoice_update_dto) && count($supplier_invoice_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_update_dto when calling supplierInvoicePost'
            );
        }



        $resourcePath = '/v1/supplierInvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }



        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($supplier_invoice_update_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($supplier_invoice_update_dto));
            } else {
                $httpBody = $supplier_invoice_update_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     * @param  \OpenAPI\Client\Model\PrebookingUpdateDto $prebooking_update_dto Optional dto for updating the prebooking account and subaccount (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     * @param  \OpenAPI\Client\Model\PrebookingUpdateDto $prebooking_update_dto Optional dto for updating the prebooking account and subaccount (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     * @param  \OpenAPI\Client\Model\PrebookingUpdateDto $prebooking_update_dto Optional dto for updating the prebooking account and subaccount (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Pre-Book invoice operation
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     * @param  \OpenAPI\Client\Model\PrebookingUpdateDto $prebooking_update_dto Optional dto for updating the prebooking account and subaccount (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the document to be Pre-Booked (required)
     * @param  string $invoice_number Reference number of the document to be Pre-Booked (required)
     * @param  \OpenAPI\Client\Model\PrebookingUpdateDto $prebooking_update_dto Optional dto for updating the prebooking account and subaccount (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $prebooking_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'prebooking_update_dto' is set
        if ($prebooking_update_dto === null || (is_array($prebooking_update_dto) && count($prebooking_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prebooking_update_dto when calling supplierInvoicePrebookInvoiceBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/prebook';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($prebooking_update_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($prebooking_update_dto));
            } else {
                $httpBody = $prebooking_update_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypeinvoiceNumber
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoicePutByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoicePutByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePutByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoicePutByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoicePutByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePutByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoicePutByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the SupplierInvoice to update (required)
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoicePutByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'supplier_invoice_update_dto' is set
        if ($supplier_invoice_update_dto === null || (is_array($supplier_invoice_update_dto) && count($supplier_invoice_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_update_dto when calling supplierInvoicePutByTypeBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($supplier_invoice_update_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($supplier_invoice_update_dto));
            } else {
                $httpBody = $supplier_invoice_update_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoicePutByinvoiceNumber
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoicePutByinvoiceNumber($invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoicePutByinvoiceNumberWithHttpInfo($invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoicePutByinvoiceNumberWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of object|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoicePutByinvoiceNumberWithHttpInfo($invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoicePutByinvoiceNumberRequest($invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 204:
                    return $this->handleResponseWithDataType(
                        'object',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 204:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'object',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoicePutByinvoiceNumberAsync
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByinvoiceNumberAsync($invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByinvoiceNumber'][0])
    {
        return $this->supplierInvoicePutByinvoiceNumberAsyncWithHttpInfo($invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoicePutByinvoiceNumberAsyncWithHttpInfo
     *
     * Update a specific SupplierInvoice
     *
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoicePutByinvoiceNumberAsyncWithHttpInfo($invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoicePutByinvoiceNumberRequest($invoice_number, $supplier_invoice_update_dto, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoicePutByinvoiceNumber'
     *
     * @param  string $invoice_number Identifies the SupplierInvoice to update (required)
     * @param  \OpenAPI\Client\Model\SupplierInvoiceUpdateDto $supplier_invoice_update_dto Defines the data for the Invoice to update (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the update is successful, the server responds with 204 No Content and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoicePutByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoicePutByinvoiceNumberRequest($invoice_number, $supplier_invoice_update_dto, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoicePutByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoicePutByinvoiceNumber'
            );
        }

        // verify the required parameter 'supplier_invoice_update_dto' is set
        if ($supplier_invoice_update_dto === null || (is_array($supplier_invoice_update_dto) && count($supplier_invoice_update_dto) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $supplier_invoice_update_dto when calling supplierInvoicePutByinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($supplier_invoice_update_dto)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($supplier_invoice_update_dto));
            } else {
                $httpBody = $supplier_invoice_update_dto;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsync
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the released document to be reversed (required)
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceReleaseInvoiceByTypeBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumber
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumber($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberAsync
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberAsync($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'][0])
    {
        return $this->supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo
     *
     * Release invoice operation
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberAsyncWithHttpInfo($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceReleaseInvoiceByinvoiceNumber'
     *
     * @param  string $invoice_number Reference number of the document to be release (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceReleaseInvoiceByinvoiceNumberRequest($invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReleaseInvoiceByinvoiceNumber'][0])
    {

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceReleaseInvoiceByinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{invoiceNumber}/action/release';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber
     *
     * Provides an action for reversing a supplier invoice/adjustment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Provides an action for reversing a supplier invoice/adjustment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Provides an action for reversing a supplier invoice/adjustment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Provides an action for reversing a supplier invoice/adjustment
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Identifies the Invoice (required)
     * @param  string $invoice_number Identifies the Invoice (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceReverseInvoiceBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/reverse';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber
     *
     * Send invoice to approval
     *
     * @param  string $document_type Document type (required)
     * @param  string $invoice_number Document number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Send invoice to approval
     *
     * @param  string $document_type Document type (required)
     * @param  string $invoice_number Document number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberAsync
     *
     * Send invoice to approval
     *
     * @param  string $document_type Document type (required)
     * @param  string $invoice_number Document number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Send invoice to approval
     *
     * @param  string $document_type Document type (required)
     * @param  string $invoice_number Document number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type (required)
     * @param  string $invoice_number Document number (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceSendToApprovalBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/sendtoapproval';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', 'application/xml', 'text/xml', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return |\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of |\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Void invoice operation
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the document to be Voided (required)
     * @param  string $invoice_number Reference number of the document to be Voided (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceVoidInvoiceBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/voidinvoice';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber
     *
     * Write-off invoice operation
     *
     * @param  string $document_type Document type of the document to be Written Off (required)
     * @param  string $invoice_number Reference number of the document to be Written Off (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \OpenAPI\Client\Model\BackgroundApiAcceptedDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto
     */
    public function supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        list($response) = $this->supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);
        return $response;
    }

    /**
     * Operation supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberWithHttpInfo
     *
     * Write-off invoice operation
     *
     * @param  string $document_type Document type of the document to be Written Off (required)
     * @param  string $invoice_number Reference number of the document to be Written Off (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \OpenAPI\Client\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \OpenAPI\Client\Model\BackgroundApiAcceptedDto|\OpenAPI\Client\Model\BackgroundApiAcceptedDto, HTTP status code, HTTP response headers (array of strings)
     */
    public function supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $request = $this->supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
                case 202:
                    return $this->handleResponseWithDataType(
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 202:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\OpenAPI\Client\Model\BackgroundApiAcceptedDto',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberAsync
     *
     * Write-off invoice operation
     *
     * @param  string $document_type Document type of the document to be Written Off (required)
     * @param  string $invoice_number Reference number of the document to be Written Off (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberAsync($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        return $this->supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background, $if_match, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo
     *
     * Write-off invoice operation
     *
     * @param  string $document_type Document type of the document to be Written Off (required)
     * @param  string $invoice_number Reference number of the document to be Written Off (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberAsyncWithHttpInfo($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'][0])
    {
        $returnType = '\OpenAPI\Client\Model\BackgroundApiAcceptedDto';
        $request = $this->supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background, $if_match, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'
     *
     * @param  string $document_type Document type of the document to be Written Off (required)
     * @param  string $invoice_number Reference number of the document to be Written Off (required)
     * @param  string|null $erp_api_background Accepts the request and queues it to be executed in the background by our least busy worker. Responds with 202 Accepted and a document containing a JobId reference and details state location. Supported values: * a URL: when the background operation is finished, a notification will be posted to the URL with a document containing a reference id, status code and a details state location. * \&quot;none\&quot; (without quotes): Fire and forget; no notification will be sent when background operation is finished. * \&quot;subscription[:&lt;name_1&gt;&#x3D;&lt;value_1&gt;,..,&lt;name_n&gt;&#x3D;&lt;value_n&gt;]\&quot; (without quotes): when the background operation is finsihed, a notification is posted to the Webhook subscription set up in Developer Portal for your integration client. Optionally a set of name-value pairs can be added. These will be sent as headers in the POST request to the Webhook subscription&#39;s url.  To find status and details of a background-api operation, GET .. v1/background/{id}. To get the response payload of a background-api operation, if any, GET .. v1/background/{id}/content (optional)
     * @param  string|null $if_match The If-Match HTTP header allows clients to update a resource only if its current version matches a specific ETag. This mechanism helps prevent conflicts when multiple clients attempt to modify the same resource simultaneously. The If-Match header should be included in the request headers using the following syntax: If-Match: \&quot;etag_value\&quot; * If the POST operation is successful, the server responds with 200 OK and includes the new ETag value in the response headers. * If the ETag on the server does not match the value provided in the If-Match header, the server responds with 412 Precondition Failed. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumberRequest($document_type, $invoice_number, $erp_api_background = null, $if_match = null, string $contentType = self::contentTypes['supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'][0])
    {

        // verify the required parameter 'document_type' is set
        if ($document_type === null || (is_array($document_type) && count($document_type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $document_type when calling supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'
            );
        }

        // verify the required parameter 'invoice_number' is set
        if ($invoice_number === null || (is_array($invoice_number) && count($invoice_number) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $invoice_number when calling supplierInvoiceWriteoffInvoiceBydocumentTypeinvoiceNumber'
            );
        }




        $resourcePath = '/v1/supplierInvoice/{documentType}/{invoiceNumber}/action/writeoff';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // header params
        if ($erp_api_background !== null) {
            $headerParams['erp-api-background'] = ObjectSerializer::toHeaderValue($erp_api_background);
        }
        // header params
        if ($if_match !== null) {
            $headerParams['If-Match'] = ObjectSerializer::toHeaderValue($if_match);
        }

        // path params
        if ($document_type !== null) {
            $resourcePath = str_replace(
                '{' . 'documentType' . '}',
                ObjectSerializer::toPathValue($document_type),
                $resourcePath
            );
        }
        // path params
        if ($invoice_number !== null) {
            $resourcePath = str_replace(
                '{' . 'invoiceNumber' . '}',
                ObjectSerializer::toPathValue($invoice_number),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
